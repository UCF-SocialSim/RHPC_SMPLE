%!TEX root =  RHPC_SMPLE_UsersManual.tex

\chapter{Extend a Platform to a Demo}\label{chap:ExtendAPlatformToADemo}
The previous chapter outlined the steps required to use the \rhpc  toolkit to create a social media platform at an abstract level, capturing the basic functionality of the platform at the upper level while leaving the specifics for implementation at a lower level. These specifics could include, for example, agent behavior representing user accounts that interact with the platform's functionality in ways that are customized to the research question being explored.

This implies a second step: %to what exactly, the example from the previous paragraph?
the implementation of this lower level, so that the toolkit can be used to run simulations of online behavior. This chapter presents the steps necessary for running simulations.

\section{Hierarchy of Functionality}
Before discussing the step-by-step functions, a conceptual diagram of a relationship is presented to show the relationships among the classes declared in the previous chapter and the classes that will be discussed and implemented here. 
Figure \ref{TBD} shows these relationships.%

\section{Step-by-Step Instructions}
Below is a list of instructions. Each step is explained in the next section.
\begin{enumerate}
	\item Create all the Header and Source Files (empty)
	\item Create a makefile that compiles all source files
	\item Populate the Header Files
	\begin{itemize}
  	  \item Definitions
	  \item Agent Package
	  \item Custom Action
	  \item Agent
	  \item Content Agent
	  \item Behavior Selection
	  \item InfoIDSelector
	  \item User Agent
	  \item FileWriter
	  \item Feed Query
	  \item Platform
	\end{itemize}
	\item Populate the Source Files 
	\begin{itemize}
	  \item Package
	  \item Action
	  \item Agent
	  \item Content
	  \item Behavior
	  \item User
	  \item Feed Query
	  \item Platform
      \end{itemize}
\end{enumerate}

\subsection{Create all the Source and Header Files}
A good first step is to simply create the (empty) files as listed in the table.

\begin{table}
\label{table:ImplementationRequiredFiles}
\begin{center}
\caption{Files requred to implement a platform }
\begin{tabular}{l | l}
\hline
 Header Files & Source Files \\
\hline
 Definitions.h & \\
 Action.h & Action.cpp \\
 Agent\_Package.h & Agent\_Package.cpp \\
 Agent.h & Agent.cpp \\
 ContentAgent.h & ContentAgent.cpp\\
 UserAgent.h & UserAgent.cpp\\
 BehaviorSelection.h & BehaviorSelection.cpp\\
 FeedQuery.h & FeedQuery.cpp \\
 FileWriter.h & \\
 InfoIDSelection.h & \\
 Platform.h & \\
\end{tabular}
\end{center}
\end{table}



\subsection{Create the Definitions for File Output Type}
Here you should define a set of types that will be used to score agents when their order of retrieval is being determined.

If any file output is needed, then a definition of output type is required. See Chapter \ref{chap:Output} for more information. 

\textit{See Twitter\_Definitions\_xamples.h for an example of both of these.}

\subsection{Create the Agent Package}
The agent package should include all information needed to construct an identical copy of an agent.

\textit{See Twitter\_Agent\_Package\_xamples.h for an example of both of these.}

\subsection{Create the Abstract Agent, the User Agent, and the Content Agent}
The agent will inherit from the abstract agent, and will include any functionality that a general agent on this platform (whether user or content) should have. It will be templated by Action (from the platform level) and Score Type from the definitions at this level. \textit{See Twitter\_Agent\_xamples.h for an example.}

\subsubsection {User Agent}
\par The user agent will descend from the abstract user agent at the platform level and the agent at the demo level, and must implement selectBehavior, selectTarget, and selectInfoIDs methods. \textit{See Twitter\_Agent\_User\_xamples.h for an example; this example omits the inheritance of the demo level agent, but it is not needed for the demo.}

\subsubsection {Content Agent}
\par The content agent will descend from the abstract agent at the platform level and from the agent at the demo level. 

The content agent must implement two significant methods:

\begin{itemize}
\item \textit{receiveAction} This must process an action when this content target is acted upon. This includes any modification to the state of the target and any changes to the action.
\item \textit{getSelfPointer} This must return a pointer to self; it is used in specific situations where the pointer must be to the lowest child class but is generated by the parent. 
\end{itemize}

\par This structure allows the user agents and content agents to inherit demo specific behavior but avoids a diamond inheritance pattern with the objects at the platform level.

\textit{See Twitter\_Agent\_Conversation\_xamples.h/.cpp for an example.}

\subsection{Create the Custom Action}
Description the custom action must be able to perform two actions:

\begin{itemize}
\item Return an output representation (see Chapter \ref{chap:Output} for examples)
\item Return a new agent package. This is a package that represents all of the information needed to create a new content agent if the result of the action is that a new agent is to be created.
\end{itemize}

\textit{See Twitter\_Action\_xamples.h/.cpp for an example.}

\subsection{Create the Feed Query}
The Feed Query must carry all of the information needed to retrieve a collection of content elements from  the platform. This generally includes a Feed Query Type, and additional information that is used to define the request. \textit{See Twitter\_Feed\_Query\_xamples.h for an example.}

\subsection{Create the Concrete Implementation of the Platform}
The main roles for the platform are:

\begin{enumerate}
\item Creation and updates of agents
\item Responding to Feed Requests
\end{enumerate}

\subsubsection{Creation of Agents}
There are eight significant methods that must be implemented for this functionality: 

\begin{itemize}
\item \textit{getPackage} Returns an agent package for an \textit{existing} agent.
\item \textit{updateAgent} (Package only): Updates an agent; the agent is identified in the package. This generally passes through to the next method
\item \textit{updateAgent} (Package and Pointer): Updates a specific agent using the data in the package
\item \textit{provideContent} This is a Repast HPC standard; given an `agent request', populate a collection of agent package information
\item \textit{providePackage} This is also a Repast HPC standard; given a specific agent, add that agent's information to a collection of agent package
\item \textit{createNewAgent} This should create a new agent and return the pointer
\item \textit{createAndAddNewAgent} This should create a new agent \textit{and} add that agent to the context. It generally works by calling the createNewAgent method, but is also responsible for managing that agent's existence within the platform.
\item \textit{setLocalPointers} When a new agent is created (or, in parallelization, when an agent is copied from another process) it may need pointers to local instances of objects. Pointers cannot be packaged and sent; instead, some mechanism for finding the equivalent object on the local platform must be made. Usually this method is also used for newly created agents.
\end{itemize}

Some of these functions are driven by the needs of parallelization, but  because they are determined by Repast HPC they must be implemented whether parallel runs are needed or not.

\textit{See Twitter\_Platform\_xamples.h/.cpp for an example.}

\subsection{Step 8: Create the Behavior Selector}
This is a class that takes an agent and returns one or more actions that the agent selects to undertake. \textit{See Twitter\_BehaviorSelection\_xamples.h/.cpp for an example.}

\subsection{Step 9: Create the InfoIDSelector}
This is a method of selecting a topic to be discussed in the content. In the example \textit{See Twitter\_InfoIDSelector\_xamples.h/.cpp for an example that achieves this entirely by typedef statements}

\subsection{Step 10: Create the FileWriter}
See Chapter \ref{chap:Output}.
